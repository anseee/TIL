Let's Swift 컨퍼런스
======================

# 1. 스위프트3 소개
## 1.1. 전반적인 내용
**Swift 역사, Swift3.0 정리, 역사 설명 버전별 변화 설명

### 1.1.1 상세 내용
	1. Swift 3.0 역사는 인터넷에서 찾아서 다시 보자.
    2. swift 3.0 집중 api 디자인 가이드라인
    3. 임포트한 오브젝티브 시 에이피아이에 네이밍 가이드라인 자동 적용
    4. 핵심 에이피아이에 네이밍 가이드라인 도입
    5. 임포트한 오브젝티브 시 에이피아이의 스위프트화 언어의 집중 및정교화 툼 품질 향상 
    6. 기본 원칙 사용 시점의 명확성 짧은 것보다 명확한 것이 더 중요 모든 선언마다주석처리 
    7. 스위프트 에볼루션 SE 문서 
    8. 코어 렝귀지  SE 문서에서 기존 버전에서 사라진 부분들 언급
    9. 함수들의 변화 옵셔널변화 디버깅 테스트 부분 변화
    10. 스위프트 라이브러리와 코어는 변화된 부분들이 많음(swift gitimpliment 들어가서 보세요) 
    11. 함수의 명확성 파운데이션 : 다지안 가이드에 맞춰 새로운 밸류 타입으로 변경 모든 타입에 NS 제거
    12. 오브젝티브 c에서도 변화가 있다. 시간이 있으면 se를 보고 없으면 가이드라인을 보자. 

# 2. 스위프트 개발환경의 변화
## 1.1. 전반적인 내용
**swift3.0 api 변화가 너무 많다
### 1.1.1. 상세내용 정리
	1. 인터페이스 빌더 새로운 어뎁티브 유아이 
	2. 디바이스 타입별 랜더링
	3. 라이브 프리뷰
	3. 디바이스 타입별 수정하면서도 확대 축소
	4. 소스에디팅 확장 환경 제공 안전해 벌써 만들어 본 사람들
	5. 알카트라즈 플러그인 개발자들은 패닉 번들 로딩 금지 잘 쓰던 나도 패닉
    6. 새로워진 api, 오프라인 api 문서, api 문서 자동생성,
    7. SFMono Font, Code-signing, provision(관리 해줌 좋네유)
    8. 현재 라인 하이라이트, 컬러 리터럴, 이미지 리터럴
    9. sanitizers 런타임 시버그 추적 스위프트 지원 
    10. 컴파일시 버그 추적은 clang static analyzer 스위프트 지원 안함
    11. addressSanitizer, ThreadSanitizer Memory Graph Debugging
    12. 디버깅 모드로 동작할 때 잠재적인 메모리 누수를 찾는다
    13. 메모리 어드레스 오염 이슈를 찾는다
    14. 이제 스위프트도 지원 스킴의 다이어그노스틱스항목, 
    15. 검출 케이스 힙, 스택 글로벌 버퍼 오버 플로우 메모리 반환 후 사용
    16. 리턴 후 사용 메모리 릭, 스레드센타이저 런타임시 쓰레드에 의한 데이터 변경에 레이스 컨디션이 발생했는지 알아낸다..
    17. scheme 의 diagnostics 항목 지원범위는 64비트 amcOS, iOS 시뮬레이터 tvOS 시뮬레이터, watchOS
    18. 테스트할때만 써봐라 검출케이스 초기화 되지 않는 뮤텍스 사용
    19. 엉뚱한 쓰레드가 언락, 쓰레드 릭,  데이터 레이스, 메모리 누수나 버려진 메모리 탐침, 디버깅 모드에서 pause된 경우, 
    20. 최신 오에스에서만 지원
    21. scheme의 Diagnostics탭에서 malloc stack 설정
    22. 모든 얼로케이션, Live 얼로케이션 오직, 루트 패스 참조메모리, 얼마나 많은 메모리가 잡혀있는지
    23. 사이클스  누수가 어떻게 다른 누수와 연결 되어있는지, 이 그래프를 파일로 저장 가능,
    24. 뷰 디버깅, 스크롤 하면 변화되는 부분들이 보인다. 빨라지고 정확해짐
    25. 클래스로 바로가기, 네비게이터에서 필터링, 오토레이아웃 디버깅
    26. LLDB 스위프트 REPL도 LLDB enables any LLDB command
    27. 아이폰에서는 옵션이 보이지 않음
    28. LLDB는 죽어도 Xcode는 적당히 살아난다(분리됨) 여러 버전의 디버거 지원 디버거는 작동적으로 선택됨
    29. swift3는 가장 최신 디버거, swift2.3은 xcode 7.3.10era 디버거
    30. 오픈소스 스위프트도 매칭된 디버거를 사용하게 된다
    31. 자동 임포트 기능 디버거 커스텀 가능
    32 .인스트루 먼트 디버깅 시 정보 표시가 더 잘보임 
    33. 시스템 트레이스 타임 프로파일러 (앱 라이프 사이클 이벤트에 따른 동작)
    34. one more thing : 플레이그라운드를 이용해서 애니메이션등을 예제로 만들어 에어드랍으로 쏴준다.
### 1.2 요약
** 전체적으로 다 좋아짐

# 3. Do Swift : 스위프트 프로젝트 도전기
## 1.1. 전반적인 내용
**발표자분의 스위프트 적용 프로젝트들과 마음가짐. 새로운 시도에 대한 이야기를 들을 수 있었다.
### 1.1.1. 상세내용 정리
	1. 기사 하나 보여줌.
	2. TIOBE Index 코드 생산성의 순위
	3. 스택오버플로우에서도 스위프트가 많이 사랑받고 기존 오브젝티브 시는 미래가 밝지 않다
	3. 스위프트 1.2 2015년 중반 에스케이 플레닛 아이오 에스 개발자 2명 5덕스 개발 함
	4. 스위프트 2.2 2016년 초중반 야놀자 아이오세스 개발자 3명, 스위프트를 하겠다, 에피소드 설명
	5. 일정이 가장 힘듬, 새로운걸 시도하기 쉽지 않다
    6. 스위프트 프로젝트 할까?. 어쨌든 스위프트 개발 해라.
    7. 병목현상 모든 변수는 var 로 통일 , 익숙한  [];ns@ 안녕
    8. 옵셔널 그리고 바인딩 컬렉션 타입 프로퍼티 등.. 
    9 .바인딩 바인딩이라는 개념 (가드 렛)
    
### 1.2. 요약
**결론 : 해봐야한다. 사용은 거의 유사하다. 단점 : 유지보수가 많이 든다. 하지만 코드 간결성이 좋아. 해결

# 4. 스위프트 Internals
## 1.1. 전반적인 내용
** 스위프트 내부 동작, 스위프트 컴파일러, 스위프트 타입 시스템, 스위프트 타입 인터널, 스위프트 파운데이션

### 1.1.1. 상세내용 정리
	1. LLVM 에 대한 간단한 설명.
	2. 현재는 엑스코드는 LLVM 컴파일러만 제공
	3. 스위프트 컴파일러는 처음에 2단계가 더 추가되었다. 
	3. 타입이 명시적으로 되어있지 않으면 먹통.
	4. 프론트단을 넘어가지 못해서 나타남 SIL 최적화.
	5. 스위프트 타입 시스템, 양방향 타입 추정 가능 타입을 위한 제약 사항으로 되어있다. 
    6. hindley-milner algorithm w var let apps abs 알고리즘이 나와있는데 참 신기하다.
    7. 타입 검사기 (type checker - constraints)
    8. Constraint Solving
    9. 타입 추정이 이렇게 과정이 복잡함
    10. 타입의 내부 구조들, 네이티브 클래스 타입, 열거형 타입 (내부에서는 스위치문 처럼 만들어짐)
    11. 구조체는 대부분의 스텐다드 타입은 90%가 struct로 만들어져있음. 기본이 되는 타입이다.
    12. 객체처럼 생명주기를 가지고 있다.
    13. 스위프트 3 파운데이션
    
## 1.2. 요약
**스위프트 컴파일러 엘엘브이엠 기반으로 만들었고, 테일러 스위프트르 좋아해서 붙었다고?, 타입 시스템은 에이치 엠 시스템을 확장 더블유 알고리즘을 이용해서 제약을 처리, 영어문서를 10번 이상 읽어봄. 

# 5. 안드로이드 개발자를 위한 스위프트
## 1.1. 전반적인 내용
**스위프트를 사용하면서 자바에 비해 좋았던 부분, VIPER 아키텍처 적용 사례 
### 1.1.1. 상세내용 정리
	1. Stored Property, Computed Property
	2. Closure, Function
	3. Functional 통계 계산 로직에서 적극적으로 사용, 특정 날짜의 데이터를 주로 다룸
	3. 스레드만 잘 처리해주면 사용자 체감상 문제 없음. 
	4. 프로토콜, 익스텐션
	5. VIPER 디스트리뷰션, 테스팅, 사용하기 쉬움 Code Generator Rxswift, KVO

## 1.2 요약
** iOS 개발은 참 좋다. 안드로이드에 비해 평화롭게 개발 할 수 있다.

# 6. RxSwift 시작하기
## 1.1. 전반적인 내용
**RxSwift에 대한 정의, 공부법, 실제 적용 사례
### 1.1.1. 상세내용 정리
	1. 1부터 10까지 더하는 문제 1부터 10까지 더하는 문제.
	2. 상태를 저장하지 않음,.
	3. 데이터 플로우, 누군가 자기를 구독해야 이벤트를 발생한다.
	3. 우선 만져보자 그리고 이해 안되는 문제들을 찾아서 공부
	4. RxMarble 사이트
	5. 플레이 그라운드에서 찾아보세요
    6. 개인적인 의견 : 배울때 욕심을 부리지 않는다 체력이 부족함.
    7. 네트워크를 리엑티브로 변경하여 사용
    8. RxSwift Community 커뮤니티, RxAlamofire 있음. 
    9. 모바일 응용프로그램 아키텍쳐, RxTodo예제 4번째를 봐라 (레퍼런스) 

## 1.2 요약
**RxSwift를 이용한 적용 사례, 그리고 어떻게 학습하는지에 대한 정보들을 들을 수 있었다.

# 7. 스위프트 패키지 매니저
## 1.1. 전반적인 내용
**들어가기, 용어 정리, 패키지 매니저 준비, 간단한 프로그램 빌드, 의존성을 포함한 프로그램 빌드, 엑스코드 프로젝트
### 1.1.1. 상세내용 정리
	1. 패키지 매니저에 대한 간단한 용어 정리.
	2. 스위프트 패키지 2017관점
	3. 홈브루 개발자가 2015년에 애플에서 일하고 있다
	3. 스위프트 패키지 매니저를 설치해서 사용해볼 수 있다.
	4. 매니페스트
	5. 스위프트 언어를 배우면 패키지 매니저를 설정 할 수 있다
    6. 프로젝트 폴더 구조.
    7. 데모
    8. 의존성을 가지는 프로젝트
    9. Coders high

## 1.2 요약
**스위프트 패키지 매니저가 존재한다는것을 알게 되었고, 파이썬 패키지를 만들때와 유사하다고 개인적으로 생각된다. 그리고 현재 존재하고 있는 패키지 매니저가 어떻게 될지..

# 8. 프로토콜 오리엔티드 프로그래밍
## 1.1. 전반적인 내용
**가장 핵심 기능 페러다임중 하나, 무엇인지, 실제로 프로젝트에 적용할 수 있을까 / 오브젝티브 시에서는 청사진의 역할만 했음, 델리게이트 데이터 소스 에서만 사용, 이런 기능을 가질것이다라는 표현만 했지만, 스위프트에서는 오브젝티브 시의 같은 기능을 하지만, 기본 구현이 가능합니다. 프토토콜에다가 익스텐션을 추가해서 특정 타입이 할일 을 지정하고 구현을 한번에 할 수 있다. / 프로토콜 예제 / 프로토콜 디폴트 구현 / 써먹는 방법, 범용적인 사용 (오브젝티브 시에서 카테고리는 클래스에서만 사용 가능) 제네릭과 사용하면 더욱더 강력하게 사용할 수 있다, 상속의 한걔를 극복할 수 있다. 스위프트의 구조체는 상속이 불가능 하지만 이 기능을 이용하여 확장 시킬 수 있다. 적은 시스템 비용, 용잉한 테스트 / 한계점, 오브젝티브 시 프로토콜과 합치는것은 불가능 자주 사용되는 델리게이트 데이터소스등 프레임워크 프로토콜에 기본구현 불가능 / 요약 벨류타입을 이용해서 성능상의 이득을 취하자, 프로토콜 익스텐션 제네릭이 만나면 환상의 조합, 상속을 통한 수직 확장이 아닌 프로토콜과 익스텐션을 통한 수평확장과 기능추가를 고민할때

### 1.1.1. 상세내용 정리
	1. 간결하다.
	2. 별도의 도구없이 작성가능하다.
	3. 다양한 형태로 변환이 가능하다.
	3. 텍스트(Text)로 저장되기 때문에 용량이 적어 보관이 용이하다.
	4. 텍스트파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다.
	5. 지원하는 프로그램과 플랫폼이 다양하다.

# 9. 스위프트 퍼포먼스 이해하기
## 1.1. 전반적인 내용
**벨류 시멘틱스 성능을 위해 고려할 것들 스위프트의 추상화 기법들의 성능, 가장 중요한 구조체 기법들 성능 요소들 최적화 할수 있는지, / 벨루 시멘틱스 벨류타입을 이용한 메카니즘 / 벨류타입의 특징은 변수 할당 시 스택에 값이 모두 저장, 전체 값이 복사됨(변수 할당시), 힙을 사용하지 않음, 벨류 타입인 구조체는 힙을 전혀 사용하지 않고 스택에 쌓임. 복사할때도 그대로 스택에 쌓임, 복사되어도 분리되어있다. 값에 의해 구분되며 값이 중요하다. 값을 모두 카피 하는데 성능에는 문제가 없을까? / 카피는 빠르다. / 이뮤터블로 해결해도 되는것이 아닌가?, 참조형이어도 값이 불변하면 스레드간에 문제생길 일이 없음, 함수형만 할 수는 없고 객체지향은 훌륭한도구다. 벨류만 참고가 좋을때도 있다. / 성능을 위해 고려해야 할 사항 메모리 할당 : 힙과 스택, 참조 카운팅, 노 아니면 예쓰, 메소드 디스패치 , 스테틱과 다이나믹, 힙할당의 문제, 빈곳을 찾고 관리하는 것은 복잡한 과정, 빈곳을 찾기가 힘듬 그리고 스레드 세이프해야한다는 점이다. 가장 큰 문제임, 스레드를 잠시 멈춰야해서 성능상 저하가 될 수 있다. 스택은 단순히 스택포인터 변수만 변경하면 되기때문에 성능에 문제가 없다. 키를 밸류 타입으로 바꿔보자. / 레퍼런스 카운팅의 문제점 변수 카피할때마다 생김, 스레드 세이프티 때문에 가장 문제,  ARC 백그라운드 안에서 많이 사용됨, / 메소드 호출하는 방식 메소드 인라이닝, 컴파일러가 최적화를 못하는 것이 큰 문제 / 추상화 기법들 클래스 구조체 프로토콜 제네릭, 클래스 힙과 레퍼런스 카운팅 사용, 구조체 스택에 다 쌓임 모두 좋음, 상속이 지원은 하지 않음, 벨류 타입안에 클래스가 숨어 있음. 결국에는 참조 타입을 가진 구조체는 레퍼런스카운팅이 일어남, 구조체에 참조타입을 줄여보자, / 프로토콜 타입 벨류타입인 구조체에서도 적용이 가능하다. / 카피 동작 정리 / 제네릭 타입, 컴파일러가 해준다./ 정리 오브젝티브 성능이 좋다. 벨류타입과 프로토콜 레퍼런스 타입에 대해서 성격을 잘 고려해야 한다. 성능을 고려하는것은 모바일 앱은 상관없으나, 렌더링하는 경우, 반복적인 작업인 경우에만 적용, 추상화 기법의 선택. / 마지막으로 정답은 없다, 하지만 이러한것들이 동작하는것들을 알고 만든다면 더 좋지 않을까요?

### 1.1.1. 상세내용 정리
	1. 간결하다.
	2. 별도의 도구없이 작성가능하다.
	3. 다양한 형태로 변환이 가능하다.
	3. 텍스트(Text)로 저장되기 때문에 용량이 적어 보관이 용이하다.
	4. 텍스트파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다.
	5. 지원하는 프로그램과 플랫폼이 다양하다.

# 10. Docker + 스위프트 서버 사이드
## 1.1. 전반적인 내용
**스위프트 세션 서버사이드 백엔드 버추얼박스 키투라 독커 데모 , 키투라 서버사이드, 백엔드 웹 프레임워크, 깃헙을 보시고 공부하세요
### 1.1.1. 상세내용 정리
	1. 간결하다.
	2. 별도의 도구없이 작성가능하다.
	3. 다양한 형태로 변환이 가능하다.
	3. 텍스트(Text)로 저장되기 때문에 용량이 적어 보관이 용이하다.
	4. 텍스트파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다.
	5. 지원하는 프로그램과 플랫폼이 다양하다.

# 7. Swift 모바일데이터베이스 : Realm
## 1.1. 전반적인 내용
**코어데이터 쓰세염? 보통 쓰기 힘들어욤.  렘에 대한 장점들 간단한 코드 설명, 렘 애드온에서 쓸수 있음. 렘 사용자 그룹 스위프트 운영
### 1.1.1. 상세내용 정리
	1. 간결하다.
	2. 별도의 도구없이 작성가능하다.
	3. 다양한 형태로 변환이 가능하다.
	3. 텍스트(Text)로 저장되기 때문에 용량이 적어 보관이 용이하다.
	4. 텍스트파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다.
	5. 지원하는 프로그램과 플랫폼이 다양하다.