#Chapter 04 흐름 제어 구문  (코드의 활용성을 높여주는 도구들)
참고 : 생략한 구문들도 있다.

일반적으로 프로그래밍 과정에서 작성하는 소스 코드를 구문이라고 한다. 하나의 앱을 만들기 위해 우리는 작성해야 할 코드는 작게는 수십 줄부터 많게는 수만줄에 이르는데, 대부분이 구문으로 이루어진다.

구문은 크게 단순 구문과 흐름 제어 구문 두 가지로 나뉜다. 단순 구문은 식이나 값 표현, 각종 객체의 선선이나 정의 등에 사용되는 일반 구문이다. 앞서 살펴본 변수나 상수 선언, 연산 처리등이 모두 단순 구문에 속하며, 이후에 배우게 될 함수나 구조체, 클래스 및 열거형 등을 정의하는 구문 역시 단순 구문에 해당한다.

흐름 제어 구문은 말 그대로 프로그램 실행 과정에서 실행 흐름을 능동적으로 제어하기 위한 목적으로 사용되는 구문을 말한다. 흐름 제어 구문은 일부 실행과정을 건너뛰거나 되돌아 오도록 흐름을 제어하며 경우에 따라 반복적으로 실행되도록 제어하기도 한다. 이번 장에서는 흐름 제어 구문에 대해 집중적으로 학습한다.

종류는 3가지다
* 반복문
* 조건문
* 제어 전달문

##4.1 반복문
For 반복문과 For ~ in 구문으로 나눌 수 있고, While과 repeat ~ while 구문으로 나눌 수 있다. for 구문은 반복할 때마다 카운터를 증가시키면서 특정 조건이 충족되는 동안 일련의 구문을 반복적으로 실행하고, for ~ in 구문은 순서에 따른 각각의 아이템에 대하여 일련의 구문을 반복적으로 실행하는 차이가 있다. 

while 반복문은  매번 루프를 시작할 때 조건을 평가하지만, repeat ~ while 구문은 루프를 완료할 때 조건을 평가한다는 특성이 있다. 주어진 조건이 처음부터 거짓이면 while문은 한 번도 실행되지 않고 종료하지만, repeat ~ while은 조건이 거짓이라도 최소 한 번은 실행된다.

반복문에서 흐름 제어를 바꾸고자 할 때에는 break 구문과 continue 구문이 사용된다. 이 구문들은 제어 전달문으로서, 적절한 시점에 사용되어 코드 블록의 실행 흐름을 옮겨주는 역할을 한다.

###4.1.3 for ~ in 구문
이 구문은 배열이나 딕셔너리, 범위 데이터의 개별 정수 또는 문자열 등 순번으로 관리되는 데이터 타입을 효과적으로 순회(Iterator)할 수 있는 방법을 제공한다. 단일 데이터가 아닌 유사한 패턴의 데이터가 여러 개 모여서 이루는 집단 자료형<Collective Types>이라고 한다. 아무튼 이런 자료형이 많이 쓰는 구문이 for ~ in라는 것이다.

```Swift
for 루프 상수 in 순회 대상 {
	실행할 구문
}

```

for ~ in 구문에서는 정의되는 루프 상수는 순회 대상이 포함하고 있는 개별 아이템들을 차례로 넘겨받아 임의로 저장하고, 실행 블록 내에서 사용할 수 있도록 해주는 역할을 합니다. 루프 상수는 루프 구문이 순회할 때마다 자동으로 재선언되므로 let 키워드를 사용하여 직접 선언할 필요가 없다는 점도 유의해야할 부분이다.

범위 데이터를 순회 처리하여 작성한 예다

```Swift
for row in 1...5 {
	print("2 x \(row) = \(row*2)")
}
```

닫힌 범위 연산자로 작성된 1...5는 1,2,3,4,5 까지의 데이터를 순서대로 생성한다. 이 범위 데이터가 for ~ in 구문의 순회 대상이 되면 루프 상수인 row에 최초로 1이 대입되고 루프 블록내의 구문이 실행한다

####루프 상수의 생략
for ~ in 구문을 사용할 때 순서대로 전달되는 각 아이탬들이 필요하지 않을 수도 있다. 이때는 루프 상수를 작성하는 대신 언더바( _ )를 사용하여 루프 상수를 생략할 수 있다.

```Swift
let size = 5
let padChar = "0"
let keyword = "3"

for _ in 1...size {
	keyword = padChar + keyword
}
```
###4.1.5 repeat ~ while 구문
스위프트 2버전에서 repeat ~ while 구문으로 변경되었다. 코드 블록을 일단 실행한 다음, 조건식을 평가하여 그다음 반복을 수행할지를 결정한다. 따라서 조건식을 ㅁ너저 평가하여 false가 반환되면 실행 블록을 아예 수행하지 않는 while 구문에 비해 실행 블록에 대해 최소 한 번의 수행은 보장하는 것이 repeat ~ while 구문의 특징이다.

```Swift
var n = 1024
while n < 1000 {
	n = n * 2
}
// n = 1024
```

###4.2.2 guard 구문
if 구문과의 차이점은 guard 구문에는 else 블록이 필수이지만, 표현식의 결과가 참일 때 실행되는 블록이 없다.

```Swift
guard 조건식 또는 표현식 else {
	실행할 구문(조건 또는 표현식의 결과가 false일 때)
}
```

guard 구문은 주로 후속 코드들이 실행되기 전에 반드시 특정 조건을 만족하는지 확인하는 용도로 사용합니다. 다시 말해 guard 구문은 특정 조건을 만족하지 않는 채 후속 코드를 실행하면 심각한 오류가 발생하는 경우, 그 대신 전체 구문을 조기 종료하기 위한 목적으로 사용한다. 따라서 guard 구문의 else 블록을 작성할 때에는 이후의 코드가 더 진행되지 않게 처리하는 작업이 필요하다. guard 구문이 주로 사용되는 함수나 메소드에서는 return 구문이 이 역할을 한다.

```Swift
func devide(base : Int) {
	guard base != 0 else {
    	print("연산할 수 없습니다.")
        return
    }
     
    let result = 100 / base
    print(result)
}
```

###4.2.3 #available 구문
앱을 개발하다보면 앱이 실행될 기기의 iOS버전별로 구문을 다르게 작성해야 할 때가 종종 있다. 사용하고자 하는 기능이 OS 버전에 따라 다르게 제공되거나 하위 버전에서는 지원되지 않는 것이 가장 큰 원인인데, 이를 보통 현업에서는 'API가 버전을 탄다'라고 표현한다. 애플에서 제공하는 코코아 터치 프레임워크의 주요 API들은 대부분 iOS 버전이 업그레이드될 때마다 개량을 거듭해온 것이어서 이처럼 iOS 버전에 따라 사용이 제한되기도 하는데, 애플 개발자용 API문서를 확인하면 API를 사용할 수 있는 버전에 대한 정보들을 확인할 수 있다.

API정보에 들어가면 availability 항목을 볼 수 있다. 이것은 메소드를 사용할 수 있는 OS버전을 알려주는 역할을 한다. 최신 OS버전에서만 지원되는 코드를 사용하게 될 때는 반드시 그보다 하위 버전의 OS를 사용하는 사용자를 고려해야한다.

#availiable 구문은 스위프트 2 버전부터 지원하기 시작한 구문이다. 그 이전에는 OS 버전을 추출하는 API를 직접 호출하여 OS 버전에 대한 값을 얻고, 이를 조건문에서 비교 처리하는 방식으로 버전별 구문을 분리했다. 예를 들먼 다음과 같다.

```Swift
import UIKit

if UIDevice.currentDevice().systemVersion.hasPrefix("9") {

} else if UIDevice.currentDevice().systemVersion.hasPrefix("8") {

} else if UIDevice.currentDevice().systemVersion.hasPrefix("7") {

} else {

}
```

이 방식에 크게 문제가 있었던 것은 아니지만, 버전을 직접 비교하는 것이 아니라 버전의 문자열을 비교해야 하므로 비교의 한계가 있었던 것 또한 사실이다. 이 방식으로 처리했던 과정을 #available 구문으로 처리하면 보다 직접적으로 OS 버전별 구문을 분리 할 수 있다.

#availiable 구문을 사용하는 형식은 다음과 같다

```Swift
if #availiable (플랫폼 이름 버전,... *) {
	해당 버전에서 사용할 수 있는 API구문
} else {
	API를 사용하지 못했을 때에 대한 실패 처리
}
```

```Swift
if #availiable (iOS 9, OSX 10.10, watchOS 1, *) {
        // iOS 9용 API 구문 또는 OS X 10.10용 API구문, watchOS 1용 API 구문
} else {
		// API를 사용하지 못했을 때에 대한 실패 처리
}
```


####구문 레이블과 break, continue
중첩된 구문들에서 continue 구문이나 break 구문을 사용하려면 약간의 문제가 생길 수 있다. 중첩된 구문 내에서 사용된 break나 continue 구문이 어떤 구문을 멈추거나 다시 시작하게 할지 명확히자 않다는 점이다. 이 때문에 break 구문이 어떤 구문을 중단시킬지, continue 구문이 어떤 구문에 작용할지 명확하게 표현해줄 필요가 이다.

구문 레이블을 정의하는 형식은 매우 단순하다. for 구문이나 while 구문, switch 구문등 레이블을 적용할 구문의 앞에 레이블을 추가하고, 구문과 레이블 사이를 콜론으로 구문해주면 끝

```Swift
레이블 이름: while 반복실행을 유지할 조건 {
	반복해서 실행할 구문
}
```

구문 앞에 작성된 레이블 이름은 break문이나 continue 문이 호출하는 대상이 됩니다. break문과 continue 문이 레이블을 사용할 때에는 구문 다음에 레이블의 이름을 작성해 주면된다.

```Swift
break 레이블 이름
continue 레이블 이름
```

하나의 코드 내에서 레이블을 여러 곳에서 사용하게 될 경우 서로 중복되지 않도록 주의해서 작성해야 한다. 구문 레이블의 효과를 이해하기 위해 아래 코드를 보자

```Swift
outer : for i in 1...5 {
	inner : for j in 1...9 {
    	if j == 3 {
        	break outer
        }
        
        print("\(i) X \(j) = \(i * j)")
    }
}
```

