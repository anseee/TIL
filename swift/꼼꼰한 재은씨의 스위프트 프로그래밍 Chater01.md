#Chapter01

##스위프트의 탄생 배경
오브젝티브 C는 수개월에 걸쳐 공부해야하고, 개발 입문자가 접하기는 다소 어렵다. 또한 성능 개선에 많은 시간을 들여야 하는데, 이는 애플이 원하는 것이 아니다. 애플이 원하는 것은 개발자들이 기능적으로 더 다양한 종류의 앱을 만들기를 원했다.
애플은 코드 최적화나 메모리관리 성능 관리등의 기술 경험 기반 개발 이유로 시스템이 맞아서 개발자들의 부담을 덜어주어야 했다. 따라서 스위프트란 언어가 탄생했다.

스위프트는 갓 입문한 사람들도 무리없이 사용할 수 있다. 그래서 나온것이 플레이 그라운드이다. 또한 코코아 코코아 터치 프레임워크를 모두 이용 가능하고, LLVM 컴파일러 옵티마이저 오토 벡터링, ARC 메모리관리 런타임 환경등 기존의 개발 환경과 모두 동일히다.

##스위프트의 특징
보통 진입장벽이 낮고 생산성이 높은 언어는 성능이 낮다. 그리고 이와 반대로 성능이 좋은 언어는 생산성이 떨어지고 진입장벽이 어려운 경우가 대부분이다. 하지만 스위프트는 성능과 생산성 진입장벽을 모두 갖춘 언어라 할 수 있겠다.

컴파일러가 스스로 상수 또는 변수를 구별해준다. 따라서 개발자들이 동적 바인딩을 지원한다는 착각에 빠질 수 있다. 스위프트는 동적 바인딩을 채택하지 않았다.
또한 오브젝티브 C에서 처럼 다른 클래스를 참조하기 위해서는 일일이 Import를 해야하지만, 스위프트는 프로젝트 전체를 네임스페이스로 사용하기 때문에 불필요한 선언 없이 바로 참조가 가능하다.

###스위프트는 다른 언어들의 특징들을 차용했다.

####딕셔너리 : 자바스크립트, 파이썬
[] 를 이용해서 배열이나 문자열을 나타냈는데 보통 해시 테이블이라 불리운다. 스위프트에서는 딕셔너리란 용어로 불리우고 쓰인다.

####데이터 타입 추론 : 함수형 프로그래밍 언어
스위프트는 데이터 타입을 생략할 수 있다. 컴파일러가 알아서 초기 선언을 참고하여 판단한다.

####데이터 구조체 선언 : C# 자바
데이터 구조체에 저장될 형식을 지정하는데 이렇게 지정하여 컴파일러에게 미리 어떤 데이터가 들어갈지 알려준다. 

####문자열 : JSP, 파이썬, 콜드 퓨전
역슬래시와 소괄호를 이용해서 문자열과 변수, 평가식을 함께 붙여서 사용할 수 있다.

####선택사항인 세미콜론 : 자바스크립트와 파이ㄴ썬
생략가능

####프로토콜 : 자바 C#
정교한 객체지향 클래스 구조체를 만드는 프로그래머는 가장 먼저 기본 언터페이스부터 설계를 시작하는 경우가 많은데 스위프트는 클래스 모음의 청사진에 대해 프로토콜이란 용어를 사용하여 만든다.

####튜플 : 리스프와 파이썬
두 개 이상의 값을 반환해야하는 경우가 있는데 스위프트에서는 이러한 반환을 튜플이란것을 사용하여 가능하게끔 했다.

####자동참조(가비지 수집과 비슷) : 자바, C#, 오브젝티브 - C
메모리 영역을 회수하는 자동 루틴이고, 스위프트는 ARC를 사용하는데 오브젝티브 - C 에서 물려받았다고 해도 과언이 아니다.

####부호 있는 정수와 부호 없는 정수 : C#과 오브젝티브 - C
스위프트는 1,2,4,8 바이트의 부호 없는 정수와 부호 있는 정수를 제공한다.

####클로저 : 리스프와 스킴에서 자바스크립트까지
소량의 코드를 묶어서 함수처럼 전달하는 클로저를 사용할 수 있다. 이러한 클로저는 람다 함수 아이디어를 개발한 리스프 스킴과 같은 언어에서 가져온 것이다.

###구조적 특징
####빠름
복합정렬 연산에서 오브젝티브 C보다 빠른 성능을 나타냅니다. 애플에서는 GCC대신 LLVM이란 컴파일러를 사용하고 있는데 이 컴파일러에서 제공하는 코드 최적화기를 사용하여 소스 컴파일과 최적화를 수행함으로써 성능을 극대화 시킨다.

####안전성
변수나 상수는 반드시 선언후 사용가능하며, 타입 추론기에 의해 초기값을 기준으로 타입을 정의함으로써 타입에 대한 안정성을 갖는다. 또한 배열과 정수는 오버플로우에 대비하여 확인을 받으며 특히 개발자가 정의하지 않는 배열 값에 승인하지 않는 값들이 주입될 수 없도록 Array Bonds check기능을 포함한다. 그리고 포인터의 직접 접근하는 시도를 미리 차단합니다. 또한 ARC를 사용하여 자동으로 메모리를 관리하므로 메모리 누수 현상에 대한 안정성을 높인다.

####현대적
스위프트는 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법을 채택하여 코드 작성이나 디버깅, 유지보수 과정에서 기존의 오브젝티브 -C 보다 훨씬 적은 양의 코드가 사용된다. 뿐만 아니라 헤더 파일을 사용하지 않고 통합으로 코드를 작성하게끔 설계되어있다.
또한 스위프트는 옵셔널 제네릭 클로저 튜플뿐만 아니라 현대 프로그래밍 언어의 특성을 다수 포함하고 있습니다.

####상호반응
Xcode6이후 스위프트 코드의 프로토타이핑을 위해서 플레이그라운드편집기를 제공한다. 스위프트 코드를 작성하고 그 결과와 메모리 스택등의 정보 확인을 즉시 확인 할 수 있어 상호반응적으로 코드를 작성할 수 있다.
또한 디버깅도 무척 쉽다.

####완전한 플랫폼ㄴ
코코아 프레임워크나 코코아 터치 프레임워크의 모든 부분을 스위프트로 접근하여 객체를 사용할수 있습니다. 오브젝티브 C로 작성되었던 핵심 프레임워크가 스위프트를 이용하여 모두 재작성되었다. 스위프트만으로도 하나의 오나전한 앱을 만들수 있다.

####통합
스위프트는 오브젝티브 C를 완전히 대체할 수 있다. 스위프트는 객체지향 언어의 특성을 모두 제공하는 동시에 자료형과 흐름 제어, 연산자 같은 저수준언어의 기본 요소를 포함하고 있다. 그 뿐만 아니라 하나의 앱에서 기존의 오브젝티브 C와 함께 사용할 수 있는 통합성도 가지고 있다. 오브젝티브 C 객체와 스위프트 객체를 서로 가져다 사용할 수 있으며 하나의 앱을 구성하는 파일 단위를 나누어 오브젝티브 C와 함께 작성하는 것도 가능합니다.

##오브젝티브-C와 스위프트 비교

###파일 통합
오브젝티브-C는 C언어를 기초로 하는 언어이다 따라서 파일 형식도 C를 따라 헤더 파일과 소스 파일(구현)로 나뉜다. 헤더 파일은 변수나 상수에 대한 선언 인터페이스에 대한 정의가 이루어지고, 소스 파일(구현)에서는 헤더 파일에서 정의된 인터페이스를 구현하는 부분이 작성된다. 

스위프트에서는 파일 하나로 통합되어 변수나 상수의 선언과 클래스 구현이 하나의 파일에서 작성된다.

###클래스
오브젝티브-C는 클래스를 작성할 때 헤더 파일에 클래스의 인터페이스를 정의하고 소스 파일에서는 정의된 인터페이스를 구현하도록 나누어져 있다.

스위프트는 클래스를 작성할 때 인터페이스 정의가 필요 없고 클래스에 대한 구현 부분만 작성하면 된다. 또한 오브젝티브-C는 반드시 상위 클래스를 상속받아서 클래스를 선언해야 하며 상속받을 클래스가 없을때는 최상위 클래스인 NSObject 클래스를 상속받아야 한다.

스위프트에서는 상속받아야 할 클래스가 특별히 없으면 아무 클래스도 상속받지 않아도 된다.

###상속
오브젝티브-C는 다중 상속을 지원하지 않지만, 자바의 인터페이스에 해당하는 개념인 프로토콜을 정의하여 클래스 객체가 준수해야 할 청사진을 제공할 수 있다. 또한 카테고리를 사용하여 기존 객체 자체를 확장할 수 있다.

스위프트 역시 다중 상속을 지원하지 않으나. 프로토콜을 정의할 수 있다. 프로토콜은 오브젝티브-C에서와 동일하게 사용된다. 오브젝티브-C에서는 클래스 객체만 확장할 수 있었던 카테고리에 비해, 스위프트의 Extension은 클래스, 구조체, 프로토콜 등 대부분 객체에 적용할 수 있다.

###범용 타입
오브젝티브-C에서는 id타입을 제공한다. 이는 범용 타입의 객체가 사용할 때 사용할 수 있다. 모든 타입의 값을 저장할 수 있고, 내부적으로 저장된 데이터 형식의 호환성만 보장된다면 어떠한 타입으로든 변환할 수 있는 타입이다. 코코아 프레임워크나 코코타 터치 프레임워크에서는 범용 타입 객체를 이용하여 타입에 구문 없이 객체를 입력받거나 반환하는 API들이 많다.

스위프트 역시 위에서 언급한 프레임워크를 사용하려면 범용 타입의 객체를 도입해야만 했는데, 이를 위해 Any타입과 AnyObject 클래스를 제공합니다. Any는 구조체, 클래스, 열거형, 함수 등 스위프트에서 제공하는 모든 타입의 값을 저장할 수 있는 타입이며, AnyObject는 클래스에 한해 데이터만 호환된다면 어떤 타입의 클래스로도 변환 할 수 있틑 객체다.

###메소드 호출
오브젝티브-C는 스몰토크의 문법을 차용하여 메소드 호출을 메시지 전송 방식으로 처리한다. 호출하는 대신 객체에 정의된 메시지를 보내는 방식이다.

스위프트에서는 일반적인 객체지향에서의 객체 호출방식을 따르기 때문에 객체와 메소드는 점(.)을 통해 연결된다.

###nil의 의미
오브젝티브-C에서는 존재하지 않는 객체에 대한 참조를 위해 nil이라는 상수를 사용한다. nil과 NULL의 차이에 대해 궁금해하는 분들이 있는데, 엄격하게 말해서 오브젝티브-C에서 정의된 nil 상수와 C에서 정의된 NULL 상수 간에 차이는 있지만, 오브젝티브-C 문법에서 두 상수는 기술적으로 혼용할 수 있다. 일반적으로 nil은 클래스 객체를 참조하는데 사용되고, NULL은 그 밖에 다른 포인터 자료형에 사용되는 경향이 있다.

```Objective-C
UIViewController *uvc = nil;
int *sPtr = NULL;
```

반면 스위프트에서는 nil은 옵셔널 타입의 기본값으로 사용되며, 값이 존재 하지 않음을 나타낸다. 스위프트에서는 NULL상수가 정의되어 있지 않다.

###포인터 사용
스위프트에서는 개발자가 직접 레퍼런스를 참조하지 않도록 하는 대신 컴파일러가 객체의 종류에 따라 레퍼런스를 참조할 것인지, 객체를 복사할 것인지를 결정한다. 클래스는 포인터를 사용하지 않아도 자동으로 레퍼런스를 참조하고, 구조체는 객체를 복사하여 사용하는 방식으로 처리한다.

###객체지향 타입
오브젝티브-C는 @interface @implement를 이용하여 선언과 구현을 합니다. 사용할때는 인스턴스를 만들어 사용한다.

스위프트에서는 객체지향용 타입으로 클래스뿐만 아니라 구조체, 열거형까지 제공한다. 이들 객체 타입은 모두 인스턴스를 만들 수 있으며, 인스턴스와 관련된 변수, 상수를 속성으로 선언하여 사용할 수 있다. 그뿐만 아니라 이들 객체 타입에 인스턴스 메서드와 타입 메서드를 작성하여 사용할 수도 있다.

```Swift
class SampleClass {

}

struct SampleStruct {

}

enum SampleEnum {

}
```

###익명함수
익명 함수의 사용은 람다 함수를 사용할 수 있게 해주는 리스프, 스킴 같은 함수형 프로그래밍 언어로부터 도입되었다고 할 수 있다. 일회횽 함수 마저 선언하고 사용해야하는 번거로움을 피하고 코드를 더욱 간결하게 만들어준다.

오브젝티브-C에서는 블록이란 개념을 통해 익명함수를 표현할수 있었는데, 스위프트에서는 클로저를 이용한 익명 함수 기능을 제공한다.

###오류처리
스위프트에서는 예정하는 지점에 미리 오류를 검출하는 코드를 작성해두고, 실제 오류가 발생할 때 정해진 코드 블록 바깥으로 던져 적절하게 처리할 수 있도록 지원한다. 스위프트에서는 오류를 검출해내고 각 오류에 효과적으로 대응할 수 있도록 전용 구문을 제공하고 있다. 많은 프로그래밍 언어에서 널리 사용하는 Try ~ Catch 구문을 채택한 스위프트는 코드를 실행하는 과정에서 오류가 발생하더라도 프로그램이 중단되는 것을 막아주고, 미리 준비된 대응 구문을 실행하여 효율적으로 오류에 대응할 수 있게 해준다.

