#Chapter2

##재귀(Recursion)
이전에는 C언어를 공부할때 공부를 안하고 빼먹는 부분이 포인터와 재귀이다. 그리고 자료구조에 들어서서 재귀를 공부하는 경우도 많다. 아무튼 이번 챕터에서는 재귀에 대해 공부를 할껀데 재귀에 대한 문법적인 이론이 아닌, 재귀적 사고를 하기 위한 챕터이다. 다양한 예제를 통해서 마스터를 하게 되고 이 챕터에서는 하노이 타워라는 예제를 통해 재귀를 이해할 것이다. 이 하노이 타워정도만 이해해도 재귀에 대한 어느정도의 사고가 가능하지만 아직도 부족하다고 느끼는 친구들이 있다. 걱정하지말고 자료구조를 공부하면서 재귀적인 사고를 더욱더 강화하면 된다. 재귀적인 사고를 마스터하기 위해서 아래와 같이 진행할 것이다.

1. 하노이 타워를 마스터하자
2. 문법을 모른다면 C언어 책에서 재귀문법을 공부하고 오자
3. 비선형구조에서 재귀적 사고를 강화하자.


##함수의 재귀적 호출의 이해

###재귀함수의 기본적인 이해
이전에 배웠던 재귀 함수를 떠올려보자 아마도 함수 안에 그 선언한 함수를 다시 호출하는 형태의 코드들의 예제를 보았을것이다. 우리가 많이 생각하는것은 안에서 함수 자신을 호출할때 재 진입하는 개념으로 많이 생각한다. 그리고 이것이 가능한 일인가?를 많이 고민한 경험이 있을것이다. 하지만 가능한가보단 이렇게 가능하게 했고 이것이 주는 의미는 무엇인가에 대해 좀더 생각하는 방향으로 가야할 것 이다.

재귀함수의 호출을 이해하는대 있어서 가장 좋은방법은 복사의 개념으로 생각하면 쉽다. 재진입이 아닌, 그 해당 함수를 복사해서 사용하는것이다. 그리고 재귀함수의 리턴은 호출한 반대로 이루어진다는 사실도 알아두도록 하자.

1부터 3까지 출력하는 재귀 함수를 보도록 하자
```C
#include <stdio.h>

void recursive(int num) {
	if (num <= 0)  // 재귀의 탈출조건
    	return; // 재귀의 탈출!
    printf("Recursive call %d \n", num);
    recursive(num - 1);
}

int main(void) {
	recursive(3);
    return 0;
}

```

위 코드를 보면 알겠지만, 재귀의 탈출조건도 굉장히 중요한 요소이다. 이 조건이 존재하지 않으면 함수를 무한적으로 호출하여 무한 루프에 빠진다. 미리 앞서 설명한 생각으로 저 코드를 보면 쉽게 이해할 수 있을 것이다.

###재귀함수의 디자인 사례
재귀함수는 자료구조나 알고리즘의 어려운 문제를 단순하게 만드는 중요한 무기가 된다. 무엇보다도 재귀는 수학적 수식을 코드로 옮길 수 있다. 예로 팩토리얼이 있겠다. 5! = 5 * 4 * 3 * 2 * 1(의미) 이 팩토리얼을 일반화 시키면 n! = n * (n-1) * (n - 2) ... * 2 * 1로 표현할 수 있다 그리고 이것을 다시 정리하면 아래와 같다.
<pre>
n! = n * (n-1)!

f(n) = n * f(n - 1) n >= 1
			1 			  n = 0
</pre>

```C
#include <stdio.h>

int Factorial(int n) {
	if (n==0)
    	return 1;
    else 
    	return n * Factorial(n-1);
}

```

위 코드처럼 표현이 가능하다. 그리고 코드보단 과정이 어떻게 되는지에 대해 이해하도록 하자.

##재귀의 활용
우리는 함수를 파악할때 호출관계 + 호출순서를 파악한다. 대부분 다 이렇게  할 것이다. 예를들면 A를 호출하고 그리고 그 반환된 값을 이용해서 B를 호출하고 B에서 C를 호출해서 C의 반환 값을 이용해서 B의 결과를 알아내는 과정을 들 수 있겠다. 그리고 호출 순서도 따진다 A가 1번 B가 2번 C가 3번 이렇게 말이다. 하지만 재귀적 사고를 위해서는 호출관계도 따지기 어렵지만, 호출순서는 파악하기게 매우 어렵다. 그래서 재귀가 어렵다고 느끼는것이다. 우리는 호출관계와 호출순서 모두를 따져야 속이 풀리니까 말이다. 하지만 그 마음가짐을 내려놓고 접근해보자.

피보나치 수열이 있다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55... 이렇게 나열되어있는데 이것을 일반화 하면 아래와 같다.
<pre>
수열의 N번째 값 = 수열의 N-1번째 값 + 수열의 N-2번째 값
</pre>

그러면 수학적으로 표현하면 다음과 같다
<pre>
n = 1일때 0
n = 2일때 1
otherwise fib(n-1) + fib(n-2)
</pre>

이것을 그대로 코드로 옮겨보자
```C
int Fibo(int n) {
	if (n == 1)
    	return 0;
    else if (n == 2)
    	return 1;
    else 
    	return Fibo(n-1) + Fibo(n-2);
}
```

그런데 우리는 여기서 끝내는것이 아니라 호출관계와 호출 순서를 따지기 시작한다. 그래야 저 함수가 신뢰가 있다고 생각하기 때문이다. 책에서 호출관계를 따진 표를 볼 수 있다. 이것은 올리지는 않겠으나, 매우 복잡한 과정을 거친다. 그리고 이 과정을 통해서 우리는 혼란이 다가온다. 따라서 재귀적인 마인드를 갖기 위해서는 문제가 발생하면 일반화 하고 재귀적 코드를 작성하고 끝내면 된다. 이 과정을 계속해서 거치면 우리는 재귀적 마인드를 얻을 수 있고 호출 순서에 대해서 신경쓰지 않게 된다. 이런 마인드를 갖도록 하자.!

###이진 탐색 알고리즘의 재귀적 표현
우리가 앞서 표현한 피보나치 수열은 수학적 수식을 통해 -> 재귀식을 뽑아내고 -> 코드로 구성을 하였다. 또한 재귀식을 함수관계와 호출순서룰 따지기가 매우 어렵다는것을 설명했다. 우리가 대부분 문제를 접하는것은 수학적으로 설명하기가 난해한 부분들의 문제들이 대부분이고 이 문제를 어떻게 해결해야하는가에 대해 우리는 이진 탐색 알고리즘을 재귀적으로 표현하면서 알아가도록 해보자. 앞서 이진 탐색 알고리즘에 대해 배웠다 그러면 이진 탐색 알고리즘이 왜 재귀적으로 표현으로 가능한가에 대해 한번 보자.
1. 탐색 범위의 중앙에 목표 값이 저장되었는지 확인
2. 저장되지 않았다면 탐색 범위를 반으로 줄여서 다시 탐색 시작 

위의 1.2번 과정을 계속해서 반복하기에 재귀적으로 표현 할 수 있겠다.

```C
int BSearchRecur(int arr[], int first, int last, int target) {

}

```

재귀적으로 함수를 호출해야 하기 때문에 탈출 조건을 넣어야 한다.

```C
int BSearchRecur(int arr[], int first, int last, int target) {
	if (first > last) 
    	return -1;
}
```

그 다음 첫번째 반복작업을 코드로 넣어보자

```C
int BSearchRecur(int arr[], int first, int last, int target) {
	if (first > last) 
    	return -1
    
    mid = (first + last) + 1;
    if (target == arr[mid])
    	return mid;
    else if (target > arr[mid])
    	return BSearchRecur(arr[], mid + 1, last, target);
    else 
    	return BSearchRecur(arr[], first, mid - 1, target);
}
```

###하노이 타워
앞서 했던 파보니치 수열과 하노이 타워의 공통점이 있다. 피보나치 수열에서 0,1이 주어지고 이 두개를 이용해서 계속해서 계산을 해나간다. 하노이 타워도 마찬가지로 이렇게 문제를 해결하면 되지만. 재귀적으로 문제를 해결하여 그것을 코드로 표현하는 과정인데 여기서 의심이 매우 든다. 그리고 우리는 그 찜찜함 때문에 계속해서 함수의 호출관계를 따지기 시작하고 호출순서까지 따지기 시작하면, 좌절과 어려움에 빠진다. 그래서 이런과정을 최대한 억제하고 재귀적인 마인드를 더욱더 갖도록 하자. 이런 훈련이 되면 우리는 남의 코드를 볼때도 함수의 호출관계와 순서를 따지지도 않고 아 이렇게 해서 동적을 하는구나 정도만 이해하면 그것으로 된다.

그러면 하노이 타워에 대해 본격적으로 알아보자. 하노이타워는 3개의 기둥이 존재하고 첫번째 기둥에 꽃혀있는 크기가 위에서 아래로 커지는 형태의 원반히 있다. 그리고 이 원반을 마지막 기둥으로 모두 옮기는게 목적이다. 여기서 두가지 조건이 있다. 한가지는 모두 한번에 옮길수 없으면 한번에 한개씩만이 가능하다. 두번째로는 작은 원반위에 큰 원반이 올라가서는 안된다. 이 두가지 조건을 가지고 하노이 타워를 해결해보자. 사실 실상에서는 너무나 쉽게 해결이되며 이것을 해결한다고 해서 도움이 되지는 않는다. 우리는 이것을 프로그램적으로 표현을 하는것이 목표고 어렵다. 재귀적으로 하노이 타워를 표현하는것은 굉장히 소스가 간결하다. 하지만 이 구현된 소스를 보고 우리는 의구심을 버릴수가 없다. 어떻게 그것이 우리가 의도한대로 움직이는것인가? 이러한 의구심을 갖는다.

자 그러면 하노이 타워에 그 일련의 과정을 파악해보자. 우선은 하노이 타워를 해보면 알겠지만 제일 큰 원반을 마지막 기둥으로 옮겨야 한다. 그런데 이것을 가져다 놓으려고하니 나머지 작은 원반들이 문제다. 작은 원반들만 처리하면될탠데 말이다.

그래서 우리는 다른 사람에게 맞겨보자. 내가 제일 큰원반을 마지막 기둥에 옮기고 싶은데 나머지가 안되니 나머지 작은 원반들을 너가 좀 맞아줘 그러면 되지 않을까? 그리고 다시 그 작은 원반들중에서도 가장 큰원반을 이동하고 싶지만 더 작은 원반들 때문에 옮길수가 없으니 그 원반들을 너가 맞아줘. 이 말 처럼 계속해서 반복을 거친다. 그러면 일반화 시켜보자

1. 작은 원반 3개를 처음에서 중간 기둥으로 이동 : 작은 원반 n-1개를 처음에서 중간으로 이동
2. 큰 원반 1개를 처음에서 마지막으로 이동 : 큰 원반 1개를 처음에서 마지막으로 이동
3. 옮겨진 작은 원반들을 다시 마지막 기둥으로 이동 : 작은 원반 n-1개를 중간에서 마지막으로 이동

계속해서 이 과정을 거치면 끝까지 내려갔을때 우리는 2개의 원반만을 남겨두고 나중에는 한개의 원반만을 이동하게 되므로 매우 쉽게 해결된다. 즉 N개를 이동하는 문제는 결국 원반 1개를 이동하는 매우 쉬운 문제로 세분화되는 것이다.

이제 이것을 코드로 옮겨보자

```C
void HanoiTowerMove(int num, char from, char by, char to) { //처음 큰 원반, 처음기둥, 중간기둥, 끝기둥

}
```

우선 재귀로 표현을 해야한 탈출 조건을 만들어야 한다. 하노이 타워에서 재귀 탈출조건은 매우 간단하다. 원반 기둥이 1개가 되면 끝을 내면 된다.

```C
void HanoiTowerMove(int num, char from, char by, char to) {
	if (num == 1) 
	{
		printf("원반1을 %c에서 %c로 이동");    
    }
    else
    {
    
    }
}	
```

자 이제 일반화한 표현을 코드로 옮겨보자 일단 1번 조건을 표현하면 다음과 같다

```C
void HanoiTowerMove(int num, char from, char by, char to) {
	if (num == 1) 
	{
		printf("원반1을 %c에서 %c로 이동");    
    }
    else
    {
    	HanoiTowerMove(num - 1, from, to, by); // 1단계
        printf("원반%d를 %c로 이동 \n", num, from, to); // 2단계
        HanoiTowerMove(num -1, by, from, to); // 3단계
    }
}	
```
