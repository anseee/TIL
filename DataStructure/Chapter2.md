#Chapter2

##재귀(Recursion)
이전에는 C언어를 공부할때 공부를 안하고 빼먹는 부분이 포인터와 재귀이다. 그리고 자료구조에 들어서서 재귀를 공부하는 경우도 많다. 아무튼 이번 챕터에서는 재귀에 대해 공부를 할껀데 재귀에 대한 문법적인 이론이 아닌, 재귀적 사고를 하기 위한 챕터이다. 다양한 예제를 통해서 마스터를 하게 되고 이 챕터에서는 하노이 타워라는 예제를 통해 재귀를 이해할 것이다. 이 하노이 타워정도만 이해해도 재귀에 대한 어느정도의 사고가 가능하지만 아직도 부족하다고 느끼는 친구들이 있다. 걱정하지말고 자료구조를 공부하면서 재귀적인 사고를 더욱더 강화하면 된다. 재귀적인 사고를 마스터하기 위해서 아래와 같이 진행할 것이다.

1. 하노이 타워를 마스터하자
2. 문법을 모른다면 C언어 책에서 재귀문법을 공부하고 오자
3. 비선형구조에서 재귀적 사고를 강화하자.


##함수의 재귀적 호출의 이해

###재귀함수의 기본적인 이해
이전에 배웠던 재귀 함수를 떠올려보자 아마도 함수 안에 그 선언한 함수를 다시 호출하는 형태의 코드들의 예제를 보았을것이다. 우리가 많이 생각하는것은 안에서 함수 자신을 호출할때 재 진입하는 개념으로 많이 생각한다. 그리고 이것이 가능한 일인가?를 많이 고민한 경험이 있을것이다. 하지만 가능한가보단 이렇게 가능하게 했고 이것이 주는 의미는 무엇인가에 대해 좀더 생각하는 방향으로 가야할 것 이다.

재귀함수의 호출을 이해하는대 있어서 가장 좋은방법은 복사의 개념으로 생각하면 쉽다. 재진입이 아닌, 그 해당 함수를 복사해서 사용하는것이다. 그리고 재귀함수의 리턴은 호출한 반대로 이루어진다는 사실도 알아두도록 하자.

1부터 3까지 출력하는 재귀 함수를 보도록 하자
```C
#include <stdio.h>

void recursive(int num) {
	if (num <= 0)  // 재귀의 탈출조건
    	return; // 재귀의 탈출!
    printf("Recursive call %d \n", num);
    recursive(num - 1);
}

int main(void) {
	recursive(3);
    return 0;
}

```

위 코드를 보면 알겠지만, 재귀의 탈출조건도 굉장히 중요한 요소이다. 이 조건이 존재하지 않으면 함수를 무한적으로 호출하여 무한 루프에 빠진다. 미리 앞서 설명한 생각으로 저 코드를 보면 쉽게 이해할 수 있을 것이다.

###재귀함수의 디자인 사례
재귀함수는 자료구조나 알고리즘의 어려운 문제를 단순하게 만드는 중요한 무기가 된다. 무엇보다도 재귀는 수학적 수식을 코드로 옮길 수 있다. 예로 팩토리얼이 있겠다. 5! = 5 * 4 * 3 * 2 * 1(의미) 이 팩토리얼을 일반화 시키면 n! = n * (n-1) * (n - 2) ... * 2 * 1로 표현할 수 있다 그리고 이것을 다시 정리하면 아래와 같다.
<pre>
n! = n * (n-1)!

f(n) = n * f(n - 1) n >= 1
			1 			  n = 0
</pre>

```C
#include <stdio.h>

int Factorial(int n) {
	if (n==0)
    	return 1;
    else 
    	return n * Factorial(n-1);
}

```

위 코드처럼 표현이 가능하다. 그리고 코드보단 과정이 어떻게 되는지에 대해 이해하도록 하자.

##재귀의 활용
우리는 함수를 파악할때 호출관계 + 호출순서를 파악한다. 대부분 다 이렇게  할 것이다. 예를들면 A를 호출하고 그리고 그 반환된 값을 이용해서 B를 호출하고 B에서 C를 호출해서 C의 반환 값을 이용해서 B의 결과를 알아내는 과정을 들 수 있겠다. 그리고 호출 순서도 따진다 A가 1번 B가 2번 C가 3번 이렇게 말이다. 하지만 재귀적 사고를 위해서는 호출관계도 따지기 어렵지만, 호출순서는 파악하기게 매우 어렵다. 그래서 재귀가 어렵다고 느끼는것이다. 우리는 호출관계와 호출순서 모두를 따져야 속이 풀리니까 말이다. 하지만 그 마음가짐을 내려놓고 접근해보자.

피보나치 수열이 있다. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55... 이렇게 나열되어있는데 이것을 일반화 하면 아래와 같다.
<pre>
수열의 N번째 값 = 수열의 N-1번째 값 + 수열의 N-2번째 값
</pre>

그러면 수학적으로 표현하면 다음과 같다
<pre>
n = 1일때 0
n = 2일때 1
otherwise fib(n-1) + fib(n-2)
</pre>

이것을 그대로 코드로 옮겨보자
```C
int Fibo(int n) {
	if (n == 1)
    	return 0;
    else if (n == 2)
    	return 1;
    else 
    	return Fibo(n-1) + Fibo(n-2);
}
```

그런데 우리는 여기서 끝내는것이 아니라 호출관계와 호출 순서를 따지기 시작한다. 그래야 저 함수가 신뢰가 있다고 생각하기 때문이다. 책에서 호출관계를 따진 표를 볼 수 있다. 이것은 올리지는 않겠으나, 매우 복잡한 과정을 거친다. 그리고 이 과정을 통해서 우리는 혼란이 다가온다. 따라서 재귀적인 마인드를 갖기 위해서는 문제가 발생하면 일반화 하고 재귀적 코드를 작성하고 끝내면 된다. 이 과정을 계속해서 거치면 우리는 재귀적 마인드를 얻을 수 있고 호출 순서에 대해서 신경쓰지 않게 된다. 이런 마인드를 갖도록 하자.!

###이진 탐색 알고리즘의 재귀적 표현
우리가 앞서 표현한 피보나치 수열은 수학적 수식을 통해 -> 재귀식을 뽑아내고 -> 코드로 구성을 하였다. 또한 재귀식을 함수관계와 호출순서룰 따지기가 매우 어렵다는것을 설명했다. 우리가 대부분 문제를 접하는것은 수학적으로 설명하기가 난해한 부분들의 문제들이 대부분이고 이 문제를 어떻게 해결해야하는가에 대해 우리는 이진 탐색 알고리즘을 재귀적으로 표현하면서 알아가도록 해보자. 앞서 이진 탐색 알고리즘에 대해 배웠다 그러면 이진 탐색 알고리즘이 왜 재귀적으로 표현으로 가능한가에 대해 한번 보자.
1. 탐색 범위의 중앙에 목표 값이 저장되었는지 확인
2. 저장되지 않았다면 탐색 범위를 반으로 줄여서 다시 탐색 시작 

위의 1.2번 과정을 계속해서 반복하기에 재귀적으로 표현 할 수 있겠다.

```C
int BSearchRecur(int arr[], int first, int last, int target) {

}

```

재귀적으로 함수를 호출해야 하기 때문에 탈출 조건을 넣어야 한다.

```C
int BSearchRecur(int arr[], int first, int last, int target) {
	if (first > last) 
    	return -1;
}
```

그 다음 첫번째 반복작업을 코드로 넣어보자

```C
int BSearchRecur(int arr[], int first, int last, int target) {
	if (first > last) 
    	return -1
    
    mid = (first + last) + 1;
    if (target == arr[mid])
    	return mid;
    else if (target > arr[mid])
    	return BSearchRecur(arr[], mid + 1, last, target);
    else 
    	return BSearchRecur(arr[], first, mid - 1, target);
}
```
